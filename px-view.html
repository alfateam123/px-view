<!--
    Relative paths assume component is being run from inside an app or another component, where dependencies are flat
    siblings. When this component is run from its own repo (e.g. ui tests, examples), we assume the server is started with
    'grunt depserve' (or similar server setup) to enable correct finding of bower dependencies for local runs.
-->
<link rel="import" href="../polymer/polymer.html"/>

<dom-module id="px-view">
  <template>
    <!-- insert element here -->
  </template>

  <!-- include lodash utility library -->
  <script src="../lodash/dist/lodash.min.js"></script>

  <script>
    'use strict';

    Polymer({

      is: 'px-view',

      properties: {
        /**
         *
         * Set the 'active' attribute on the <px-view> element to true and the components will be
         * loaded and displayed
         *
         * @attribute preload
         * @type Boolean
         * @default false
        */
        active: {
          type: Boolean,
          value: false
        },
        /**
         *
         * Set the 'preload' attribute on the <px-view> element and the components will be
         * loaded immediately or
         * lazy-loaded on demand. Lazy-loading is on by default to avoid unnecessary HTTP requests.
         *
         * @attribute preload
         * @type Boolean
         * @default false
        */
        preload: {
          type: Boolean,
          value: false
        },
        /**
         *
         * Status tracks a px-view component over it's lifecycle
         * Steps: 'unloaded' -> 'loading' -> 'loaded' || 'failed' -> 'attached' -> 'hidden' || 'shown'
         *
         * @attribute status
         * @type String
         * @readonly
         * @access public
        */
        status: {
          type: String,
          value: 'unloaded',
          notify: true,
          reflectToAttribute: true
        },
        /**
         *
         * elementTagName sets the name of the tag to attach to the DOM which must match component name
         *
         * @attribute elementTagName
         * @type String
         * @access private
        */
        _elementTagName: {
          type: String,
          computed: '_computeElementTagName(elementHref)',
          observer: '_elementTagNameUpdated'
        },
        /**
         *
         * elementHref defines relative URL path of web component html file
         *
         * @attribute elementHref
         * @type String
         * @access public
        */
        elementHref: {
          type: String
        },
        /**
         *
         * The display property defines the value of the component's display property when view is shown
         *
         * @attribute elementHref
         * @type String
         * @access public
         * @default 'block'
        */
        display: {
          type: String,
          value: "block"
        },
        /**
         *
         * Data to be passd through to view when it is attached.
         * Must be passed in as a stringified object using JSON.stringify()
         *
         * @attribute elementData
         * @type Object
         * @access public
         * @default {}
        */
        elementData: {
          type: Object,
          value: function() { return {}; }
        },

        _importLink: {
          type: Object,
          value: function() { return {}; }
        }

      },

      observers: [
        '_updateElementData(elementData.*)',
        '_checkStatus(status, active, preload, display, _elementTagName)'
      ],

      _updateElementData: function(newElementData){
          //console.log("[winterPxView::updateElementData]", this._element, this.elementData);
          if(this._element){
            //console.log("[winterPxView::updateElementData] setting it!");
//            this._element.setAttribute("element-data", JSON.stringify(this.elementData));
            this.set("_element.elementData", JSON.stringify(this.elementData))
          }
      },

      _element: null, // Reference to the loaded view DOM element

      // when state is 'unloaded', if active or preload are true, start loading
      _onUnloaded: function() {
        if (this.active || this.preload) {
          this._loadElement();
        }
      },

      _onLoading: function() {
        // do nothing
      },

      // when state is 'loaded', if active, attach element to DOM
      _onLoaded: function() {
        if (this.active) {
          this._attachElement();
        }
      },

      // when state is 'attached', if active, set status to 'shown', otherwise 'hidden'
      _onAttached: function() {
        var newStatus = this.active ? 'shown' : 'hidden';
        this.set('status', newStatus);
      },

      // when state is 'shown', if active, set element display property
      _onShown: function() {
        if (this.active) {
          this._element.style.display = this.display;
	  this._element.isElementShown = true;
        } else {
          this.set('status', 'hidden');
        }
      },

      // when state is 'hidden', if active, set element display property to 'none'
      _onHidden: function() {
        if (!this.active) {
          this._element.style.display = 'none';
	  this._element.isElementShown = false;
        } else {
          this.set('status', 'shown');
        }
      },

      // _stateFunctions is an object literal with references to functions
      // this maps state string values to state functions
      _getStateFunction: function(status) {
          console.log("new status: ", status);
        var stateFunctions = {
          'unloaded': this._onUnloaded,
          'loading': this._onLoading,
          'loaded': this._onLoaded,
          'attached': this._onAttached,
          'shown': this._onShown,
          'hidden': this._onHidden,
          "failed": this._onFailed
        };
        return stateFunctions[status];
      },

      _onFailed: function(){
          // nothing to do
      },

      // 'unloaded' -> 'loading' -> 'loaded' || 'failed' -> 'attached' -> 'hidden' || 'shown'
      _checkStatus: function() {
        // lookup state function and call it using fn.apply to maintain scope
        this._getStateFunction(this.status).apply(this);
      },

      _attachElement: function() {
        // confirm element tag name matches loaded element
        this._element = document.createElement(this._elementTagName);
        this._element.id = this._elementTagName + '-' + new Date().getTime();
        this._element.setAttribute('element-data', JSON.stringify(this.elementData));
        Polymer.dom(this.root).appendChild(this._element);
        this.set('status', 'attached');
      },

      _loadElement: function() {
        this.set('status', 'loading');
        var that = this;
        this._importLink = this.importHref(this.elementHref, function(e) {
          if(_.isEmpty(that._importLink)) {
            that.set('status', 'loaded');
          } else {
            var modulesLoaded = Polymer.dom(that._importLink.import).querySelectorAll('dom-module');
            if(modulesLoaded.some(function(ele){return ele.id === that._elementTagName;})) {
              that.set('status', 'loaded');
            } else {
              console.log('Error: dom-module of imported element does not match element tag name');
              that.set('status', 'failed');
            }
          }
        }, function(error) {
          this.set('status', 'failed');
        });
      },

      _computeElementTagName: function() {
        var filenameRegex = /(?=([\w-]+)\.\w{3,4}$).+/;
        var match;
        if ((match = filenameRegex.exec(this.elementHref)) !== null) {
          if (match.index === filenameRegex.lastIndex) {
            filenameRegex.lastIndex++;
          }
        }
        return match[1];
      },

      _elementTagNameUpdated: function(current, previous) {
        if(typeof previous !== 'undefined') {
          // polymer has changed the tagname, time to reset!
          this._resetView();
        }
      },

      _resetView: function() {
        this._removeAllElements();
        this.set('_importLink', {});
        this.set('status', 'unloaded');
      },

      _removeAllElements: function() {
        var nodes = Polymer.dom(this.root).children;
        var that = this;
        _.each(nodes, function(node) {
          Polymer.dom(that.root).removeChild(node);
        });
      }

    });
  </script>
</dom-module>
